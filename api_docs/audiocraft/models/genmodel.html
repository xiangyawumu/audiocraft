<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>audiocraft.models.genmodel API documentation</title>
<meta name="description" content="Base implementation for audio generative models. This base implementation
combines all the required components to run inference with pretrained audio
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>audiocraft.models.genmodel</code></h1>
</header>
<section id="section-intro">
<p>Base implementation for audio generative models. This base implementation
combines all the required components to run inference with pretrained audio
generative models. It can be easily inherited by downstream model classes to
provide easy access to the generation API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

&#34;&#34;&#34;
Base implementation for audio generative models. This base implementation
combines all the required components to run inference with pretrained audio
generative models. It can be easily inherited by downstream model classes to
provide easy access to the generation API.
&#34;&#34;&#34;

from abc import ABC, abstractmethod
import typing as tp

import omegaconf
import torch

from .encodec import CompressionModel
from .lm import LMModel
from .builders import get_wrapped_compression_model
from ..data.audio_utils import convert_audio
from ..modules.conditioners import ConditioningAttributes
from ..utils.autocast import TorchAutocast


class BaseGenModel(ABC):
    &#34;&#34;&#34;Base generative model with convenient generation API.

    Args:
        name (str): name of the model.
        compression_model (CompressionModel): Compression model
            used to map audio to invertible discrete representations.
        lm (LMModel): Language model over discrete representations.
        max_duration (float, optional): maximum duration the model can produce,
            otherwise, inferred from the training params.
    &#34;&#34;&#34;
    def __init__(self, name: str, compression_model: CompressionModel, lm: LMModel,
                 max_duration: tp.Optional[float] = None):
        self.name = name
        self.compression_model = compression_model
        self.lm = lm
        self.cfg: tp.Optional[omegaconf.DictConfig] = None
        # Just to be safe, let&#39;s put everything in eval mode.
        self.compression_model.eval()
        self.lm.eval()

        if hasattr(lm, &#39;cfg&#39;):
            cfg = lm.cfg
            assert isinstance(cfg, omegaconf.DictConfig)
            self.cfg = cfg

        if self.cfg is not None:
            self.compression_model = get_wrapped_compression_model(self.compression_model, self.cfg)

        if max_duration is None:
            if self.cfg is not None:
                max_duration = lm.cfg.dataset.segment_duration  # type: ignore
            else:
                raise ValueError(&#34;You must provide max_duration when building directly your GenModel&#34;)
        assert max_duration is not None

        self.max_duration: float = max_duration
        self.duration = self.max_duration

        # self.extend_stride is the length of audio extension when generating samples longer
        # than self.max_duration. NOTE: the derived class must set self.extend_stride to a
        # positive float value when generating with self.duration &gt; self.max_duration.
        self.extend_stride: tp.Optional[float] = None
        self.device = next(iter(lm.parameters())).device
        self.generation_params: dict = {}
        self._progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None
        if self.device.type == &#39;cpu&#39;:
            self.autocast = TorchAutocast(enabled=False)
        else:
            self.autocast = TorchAutocast(
                enabled=True, device_type=self.device.type, dtype=torch.float16)

    @property
    def frame_rate(self) -&gt; float:
        &#34;&#34;&#34;Roughly the number of AR steps per seconds.&#34;&#34;&#34;
        return self.compression_model.frame_rate

    @property
    def sample_rate(self) -&gt; int:
        &#34;&#34;&#34;Sample rate of the generated audio.&#34;&#34;&#34;
        return self.compression_model.sample_rate

    @property
    def audio_channels(self) -&gt; int:
        &#34;&#34;&#34;Audio channels of the generated audio.&#34;&#34;&#34;
        return self.compression_model.channels

    def set_custom_progress_callback(self, progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None):
        &#34;&#34;&#34;Override the default progress callback.&#34;&#34;&#34;
        self._progress_callback = progress_callback

    @abstractmethod
    def set_generation_params(self, *args, **kwargs):
        &#34;&#34;&#34;Set the generation parameters.&#34;&#34;&#34;
        raise NotImplementedError(&#34;No base implementation for setting generation params.&#34;)

    @staticmethod
    @abstractmethod
    def get_pretrained(name: str, device=None):
        raise NotImplementedError(&#34;No base implementation for getting pretrained model&#34;)

    @torch.no_grad()
    def _prepare_tokens_and_attributes(
            self,
            descriptions: tp.Sequence[tp.Optional[str]],
            prompt: tp.Optional[torch.Tensor],
    ) -&gt; tp.Tuple[tp.List[ConditioningAttributes], tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;Prepare model inputs.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            prompt (torch.Tensor): A batch of waveforms used for continuation.
        &#34;&#34;&#34;
        attributes = [
            ConditioningAttributes(text={&#39;description&#39;: description})
            for description in descriptions]

        if prompt is not None:
            if descriptions is not None:
                assert len(descriptions) == len(prompt), &#34;Prompt and nb. descriptions doesn&#39;t match&#34;
            prompt = prompt.to(self.device)
            prompt_tokens, scale = self.compression_model.encode(prompt)
            assert scale is None
        else:
            prompt_tokens = None
        return attributes, prompt_tokens

    def generate_unconditional(self, num_samples: int, progress: bool = False,
                               return_tokens: bool = False) -&gt; tp.Union[torch.Tensor,
                                                                        tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples in an unconditional manner.

        Args:
            num_samples (int): Number of samples to be generated.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        descriptions: tp.List[tp.Optional[str]] = [None] * num_samples
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate(self, descriptions: tp.List[str], progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on text.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        assert prompt_tokens is None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate_continuation(self, prompt: torch.Tensor, prompt_sample_rate: int,
                              descriptions: tp.Optional[tp.List[tp.Optional[str]]] = None,
                              progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on audio prompts and an optional text description.

        Args:
            prompt (torch.Tensor): A batch of waveforms used for continuation.
                Prompt should be [B, C, T], or [C, T] if only one sample is generated.
            prompt_sample_rate (int): Sampling rate of the given audio waveforms.
            descriptions (list of str, optional): A list of strings used as text conditioning. Defaults to None.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        if prompt.dim() == 2:
            prompt = prompt[None]
        if prompt.dim() != 3:
            raise ValueError(&#34;prompt should have 3 dimensions: [B, C, T] (C = 1).&#34;)
        prompt = convert_audio(prompt, prompt_sample_rate, self.sample_rate, self.audio_channels)
        if descriptions is None:
            descriptions = [None] * len(prompt)
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, prompt)
        assert prompt_tokens is not None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def _generate_tokens(self, attributes: tp.List[ConditioningAttributes],
                         prompt_tokens: tp.Optional[torch.Tensor], progress: bool = False) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate discrete audio tokens given audio prompt and/or conditions.

        Args:
            attributes (list of ConditioningAttributes): Conditions used for generation (here text).
            prompt_tokens (torch.Tensor, optional): Audio prompt used for continuation.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        Returns:
            torch.Tensor: Generated audio, of shape [B, C, T], T is defined by the generation params.
        &#34;&#34;&#34;
        total_gen_len = int(self.duration * self.frame_rate)
        max_prompt_len = int(min(self.duration, self.max_duration) * self.frame_rate)
        current_gen_offset: int = 0

        def _progress_callback(generated_tokens: int, tokens_to_generate: int):
            generated_tokens += current_gen_offset
            if self._progress_callback is not None:
                # Note that total_gen_len might be quite wrong depending on the
                # codebook pattern used, but with delay it is almost accurate.
                self._progress_callback(generated_tokens, tokens_to_generate)
            else:
                print(f&#39;{generated_tokens: 6d} / {tokens_to_generate: 6d}&#39;, end=&#39;\r&#39;)

        if prompt_tokens is not None:
            assert max_prompt_len &gt;= prompt_tokens.shape[-1], \
                &#34;Prompt is longer than audio to generate&#34;

        callback = None
        if progress:
            callback = _progress_callback

        if self.duration &lt;= self.max_duration:
            # generate by sampling from LM, simple case.
            with self.autocast:
                gen_tokens = self.lm.generate(
                    prompt_tokens, attributes,
                    callback=callback, max_gen_len=total_gen_len, **self.generation_params)

        else:
            assert self.extend_stride is not None, &#34;Stride should be defined to generate beyond max_duration&#34;
            assert self.extend_stride &lt; self.max_duration, &#34;Cannot stride by more than max generation duration.&#34;
            all_tokens = []
            if prompt_tokens is None:
                prompt_length = 0
            else:
                all_tokens.append(prompt_tokens)
                prompt_length = prompt_tokens.shape[-1]

            stride_tokens = int(self.frame_rate * self.extend_stride)
            while current_gen_offset + prompt_length &lt; total_gen_len:
                time_offset = current_gen_offset / self.frame_rate
                chunk_duration = min(self.duration - time_offset, self.max_duration)
                max_gen_len = int(chunk_duration * self.frame_rate)
                with self.autocast:
                    gen_tokens = self.lm.generate(
                        prompt_tokens, attributes,
                        callback=callback, max_gen_len=max_gen_len, **self.generation_params)
                if prompt_tokens is None:
                    all_tokens.append(gen_tokens)
                else:
                    all_tokens.append(gen_tokens[:, :, prompt_tokens.shape[-1]:])
                prompt_tokens = gen_tokens[:, :, stride_tokens:]
                prompt_length = prompt_tokens.shape[-1]
                current_gen_offset += stride_tokens

            gen_tokens = torch.cat(all_tokens, dim=-1)
        return gen_tokens

    def generate_audio(self, gen_tokens: torch.Tensor) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate Audio from tokens.&#34;&#34;&#34;
        assert gen_tokens.dim() == 3
        with torch.no_grad():
            gen_audio = self.compression_model.decode(gen_tokens, None)
        return gen_audio</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel"><code class="flex name class">
<span>class <span class="ident">BaseGenModel</span></span>
<span>(</span><span>name:Â str, compression_model:Â <a title="audiocraft.models.encodec.CompressionModel" href="encodec.html#audiocraft.models.encodec.CompressionModel">CompressionModel</a>, lm:Â <a title="audiocraft.models.lm.LMModel" href="lm.html#audiocraft.models.lm.LMModel">LMModel</a>, max_duration:Â Optional[float]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base generative model with convenient generation API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the model.</dd>
<dt><strong><code>compression_model</code></strong> :&ensp;<code>CompressionModel</code></dt>
<dd>Compression model
used to map audio to invertible discrete representations.</dd>
<dt><strong><code>lm</code></strong> :&ensp;<code>LMModel</code></dt>
<dd>Language model over discrete representations.</dd>
<dt><strong><code>max_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>maximum duration the model can produce,
otherwise, inferred from the training params.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseGenModel(ABC):
    &#34;&#34;&#34;Base generative model with convenient generation API.

    Args:
        name (str): name of the model.
        compression_model (CompressionModel): Compression model
            used to map audio to invertible discrete representations.
        lm (LMModel): Language model over discrete representations.
        max_duration (float, optional): maximum duration the model can produce,
            otherwise, inferred from the training params.
    &#34;&#34;&#34;
    def __init__(self, name: str, compression_model: CompressionModel, lm: LMModel,
                 max_duration: tp.Optional[float] = None):
        self.name = name
        self.compression_model = compression_model
        self.lm = lm
        self.cfg: tp.Optional[omegaconf.DictConfig] = None
        # Just to be safe, let&#39;s put everything in eval mode.
        self.compression_model.eval()
        self.lm.eval()

        if hasattr(lm, &#39;cfg&#39;):
            cfg = lm.cfg
            assert isinstance(cfg, omegaconf.DictConfig)
            self.cfg = cfg

        if self.cfg is not None:
            self.compression_model = get_wrapped_compression_model(self.compression_model, self.cfg)

        if max_duration is None:
            if self.cfg is not None:
                max_duration = lm.cfg.dataset.segment_duration  # type: ignore
            else:
                raise ValueError(&#34;You must provide max_duration when building directly your GenModel&#34;)
        assert max_duration is not None

        self.max_duration: float = max_duration
        self.duration = self.max_duration

        # self.extend_stride is the length of audio extension when generating samples longer
        # than self.max_duration. NOTE: the derived class must set self.extend_stride to a
        # positive float value when generating with self.duration &gt; self.max_duration.
        self.extend_stride: tp.Optional[float] = None
        self.device = next(iter(lm.parameters())).device
        self.generation_params: dict = {}
        self._progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None
        if self.device.type == &#39;cpu&#39;:
            self.autocast = TorchAutocast(enabled=False)
        else:
            self.autocast = TorchAutocast(
                enabled=True, device_type=self.device.type, dtype=torch.float16)

    @property
    def frame_rate(self) -&gt; float:
        &#34;&#34;&#34;Roughly the number of AR steps per seconds.&#34;&#34;&#34;
        return self.compression_model.frame_rate

    @property
    def sample_rate(self) -&gt; int:
        &#34;&#34;&#34;Sample rate of the generated audio.&#34;&#34;&#34;
        return self.compression_model.sample_rate

    @property
    def audio_channels(self) -&gt; int:
        &#34;&#34;&#34;Audio channels of the generated audio.&#34;&#34;&#34;
        return self.compression_model.channels

    def set_custom_progress_callback(self, progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None):
        &#34;&#34;&#34;Override the default progress callback.&#34;&#34;&#34;
        self._progress_callback = progress_callback

    @abstractmethod
    def set_generation_params(self, *args, **kwargs):
        &#34;&#34;&#34;Set the generation parameters.&#34;&#34;&#34;
        raise NotImplementedError(&#34;No base implementation for setting generation params.&#34;)

    @staticmethod
    @abstractmethod
    def get_pretrained(name: str, device=None):
        raise NotImplementedError(&#34;No base implementation for getting pretrained model&#34;)

    @torch.no_grad()
    def _prepare_tokens_and_attributes(
            self,
            descriptions: tp.Sequence[tp.Optional[str]],
            prompt: tp.Optional[torch.Tensor],
    ) -&gt; tp.Tuple[tp.List[ConditioningAttributes], tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;Prepare model inputs.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            prompt (torch.Tensor): A batch of waveforms used for continuation.
        &#34;&#34;&#34;
        attributes = [
            ConditioningAttributes(text={&#39;description&#39;: description})
            for description in descriptions]

        if prompt is not None:
            if descriptions is not None:
                assert len(descriptions) == len(prompt), &#34;Prompt and nb. descriptions doesn&#39;t match&#34;
            prompt = prompt.to(self.device)
            prompt_tokens, scale = self.compression_model.encode(prompt)
            assert scale is None
        else:
            prompt_tokens = None
        return attributes, prompt_tokens

    def generate_unconditional(self, num_samples: int, progress: bool = False,
                               return_tokens: bool = False) -&gt; tp.Union[torch.Tensor,
                                                                        tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples in an unconditional manner.

        Args:
            num_samples (int): Number of samples to be generated.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        descriptions: tp.List[tp.Optional[str]] = [None] * num_samples
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate(self, descriptions: tp.List[str], progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on text.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        assert prompt_tokens is None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate_continuation(self, prompt: torch.Tensor, prompt_sample_rate: int,
                              descriptions: tp.Optional[tp.List[tp.Optional[str]]] = None,
                              progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on audio prompts and an optional text description.

        Args:
            prompt (torch.Tensor): A batch of waveforms used for continuation.
                Prompt should be [B, C, T], or [C, T] if only one sample is generated.
            prompt_sample_rate (int): Sampling rate of the given audio waveforms.
            descriptions (list of str, optional): A list of strings used as text conditioning. Defaults to None.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        if prompt.dim() == 2:
            prompt = prompt[None]
        if prompt.dim() != 3:
            raise ValueError(&#34;prompt should have 3 dimensions: [B, C, T] (C = 1).&#34;)
        prompt = convert_audio(prompt, prompt_sample_rate, self.sample_rate, self.audio_channels)
        if descriptions is None:
            descriptions = [None] * len(prompt)
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, prompt)
        assert prompt_tokens is not None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def _generate_tokens(self, attributes: tp.List[ConditioningAttributes],
                         prompt_tokens: tp.Optional[torch.Tensor], progress: bool = False) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate discrete audio tokens given audio prompt and/or conditions.

        Args:
            attributes (list of ConditioningAttributes): Conditions used for generation (here text).
            prompt_tokens (torch.Tensor, optional): Audio prompt used for continuation.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        Returns:
            torch.Tensor: Generated audio, of shape [B, C, T], T is defined by the generation params.
        &#34;&#34;&#34;
        total_gen_len = int(self.duration * self.frame_rate)
        max_prompt_len = int(min(self.duration, self.max_duration) * self.frame_rate)
        current_gen_offset: int = 0

        def _progress_callback(generated_tokens: int, tokens_to_generate: int):
            generated_tokens += current_gen_offset
            if self._progress_callback is not None:
                # Note that total_gen_len might be quite wrong depending on the
                # codebook pattern used, but with delay it is almost accurate.
                self._progress_callback(generated_tokens, tokens_to_generate)
            else:
                print(f&#39;{generated_tokens: 6d} / {tokens_to_generate: 6d}&#39;, end=&#39;\r&#39;)

        if prompt_tokens is not None:
            assert max_prompt_len &gt;= prompt_tokens.shape[-1], \
                &#34;Prompt is longer than audio to generate&#34;

        callback = None
        if progress:
            callback = _progress_callback

        if self.duration &lt;= self.max_duration:
            # generate by sampling from LM, simple case.
            with self.autocast:
                gen_tokens = self.lm.generate(
                    prompt_tokens, attributes,
                    callback=callback, max_gen_len=total_gen_len, **self.generation_params)

        else:
            assert self.extend_stride is not None, &#34;Stride should be defined to generate beyond max_duration&#34;
            assert self.extend_stride &lt; self.max_duration, &#34;Cannot stride by more than max generation duration.&#34;
            all_tokens = []
            if prompt_tokens is None:
                prompt_length = 0
            else:
                all_tokens.append(prompt_tokens)
                prompt_length = prompt_tokens.shape[-1]

            stride_tokens = int(self.frame_rate * self.extend_stride)
            while current_gen_offset + prompt_length &lt; total_gen_len:
                time_offset = current_gen_offset / self.frame_rate
                chunk_duration = min(self.duration - time_offset, self.max_duration)
                max_gen_len = int(chunk_duration * self.frame_rate)
                with self.autocast:
                    gen_tokens = self.lm.generate(
                        prompt_tokens, attributes,
                        callback=callback, max_gen_len=max_gen_len, **self.generation_params)
                if prompt_tokens is None:
                    all_tokens.append(gen_tokens)
                else:
                    all_tokens.append(gen_tokens[:, :, prompt_tokens.shape[-1]:])
                prompt_tokens = gen_tokens[:, :, stride_tokens:]
                prompt_length = prompt_tokens.shape[-1]
                current_gen_offset += stride_tokens

            gen_tokens = torch.cat(all_tokens, dim=-1)
        return gen_tokens

    def generate_audio(self, gen_tokens: torch.Tensor) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate Audio from tokens.&#34;&#34;&#34;
        assert gen_tokens.dim() == 3
        with torch.no_grad():
            gen_audio = self.compression_model.decode(gen_tokens, None)
        return gen_audio</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="audiocraft.models.audiogen.AudioGen" href="audiogen.html#audiocraft.models.audiogen.AudioGen">AudioGen</a></li>
<li><a title="audiocraft.models.magnet.MAGNeT" href="magnet.html#audiocraft.models.magnet.MAGNeT">MAGNeT</a></li>
<li><a title="audiocraft.models.musicgen.MusicGen" href="musicgen.html#audiocraft.models.musicgen.MusicGen">MusicGen</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.get_pretrained"><code class="name flex">
<span>def <span class="ident">get_pretrained</span></span>(<span>name:Â str, device=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def get_pretrained(name: str, device=None):
    raise NotImplementedError(&#34;No base implementation for getting pretrained model&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.audio_channels"><code class="name">var <span class="ident">audio_channels</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Audio channels of the generated audio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def audio_channels(self) -&gt; int:
    &#34;&#34;&#34;Audio channels of the generated audio.&#34;&#34;&#34;
    return self.compression_model.channels</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.frame_rate"><code class="name">var <span class="ident">frame_rate</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Roughly the number of AR steps per seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_rate(self) -&gt; float:
    &#34;&#34;&#34;Roughly the number of AR steps per seconds.&#34;&#34;&#34;
    return self.compression_model.frame_rate</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.sample_rate"><code class="name">var <span class="ident">sample_rate</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Sample rate of the generated audio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self) -&gt; int:
    &#34;&#34;&#34;Sample rate of the generated audio.&#34;&#34;&#34;
    return self.compression_model.sample_rate</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, descriptions:Â List[str], progress:Â boolÂ =Â False, return_tokens:Â boolÂ =Â False) â€‘>Â Union[torch.Tensor,Â Tuple[torch.Tensor,Â torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate samples conditioned on text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>descriptions</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings used as text conditioning.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, descriptions: tp.List[str], progress: bool = False, return_tokens: bool = False) \
        -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples conditioned on text.

    Args:
        descriptions (list of str): A list of strings used as text conditioning.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
    assert prompt_tokens is None
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_audio"><code class="name flex">
<span>def <span class="ident">generate_audio</span></span>(<span>self, gen_tokens:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Audio from tokens.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_audio(self, gen_tokens: torch.Tensor) -&gt; torch.Tensor:
    &#34;&#34;&#34;Generate Audio from tokens.&#34;&#34;&#34;
    assert gen_tokens.dim() == 3
    with torch.no_grad():
        gen_audio = self.compression_model.decode(gen_tokens, None)
    return gen_audio</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_continuation"><code class="name flex">
<span>def <span class="ident">generate_continuation</span></span>(<span>self, prompt:Â torch.Tensor, prompt_sample_rate:Â int, descriptions:Â Optional[List[Optional[str]]]Â =Â None, progress:Â boolÂ =Â False, return_tokens:Â boolÂ =Â False) â€‘>Â Union[torch.Tensor,Â Tuple[torch.Tensor,Â torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate samples conditioned on audio prompts and an optional text description.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>A batch of waveforms used for continuation.
Prompt should be [B, C, T], or [C, T] if only one sample is generated.</dd>
<dt><strong><code>prompt_sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling rate of the given audio waveforms.</dd>
<dt><strong><code>descriptions</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of strings used as text conditioning. Defaults to None.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_continuation(self, prompt: torch.Tensor, prompt_sample_rate: int,
                          descriptions: tp.Optional[tp.List[tp.Optional[str]]] = None,
                          progress: bool = False, return_tokens: bool = False) \
        -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples conditioned on audio prompts and an optional text description.

    Args:
        prompt (torch.Tensor): A batch of waveforms used for continuation.
            Prompt should be [B, C, T], or [C, T] if only one sample is generated.
        prompt_sample_rate (int): Sampling rate of the given audio waveforms.
        descriptions (list of str, optional): A list of strings used as text conditioning. Defaults to None.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    if prompt.dim() == 2:
        prompt = prompt[None]
    if prompt.dim() != 3:
        raise ValueError(&#34;prompt should have 3 dimensions: [B, C, T] (C = 1).&#34;)
    prompt = convert_audio(prompt, prompt_sample_rate, self.sample_rate, self.audio_channels)
    if descriptions is None:
        descriptions = [None] * len(prompt)
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, prompt)
    assert prompt_tokens is not None
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_unconditional"><code class="name flex">
<span>def <span class="ident">generate_unconditional</span></span>(<span>self, num_samples:Â int, progress:Â boolÂ =Â False, return_tokens:Â boolÂ =Â False) â€‘>Â Union[torch.Tensor,Â Tuple[torch.Tensor,Â torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate samples in an unconditional manner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to be generated.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_unconditional(self, num_samples: int, progress: bool = False,
                           return_tokens: bool = False) -&gt; tp.Union[torch.Tensor,
                                                                    tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples in an unconditional manner.

    Args:
        num_samples (int): Number of samples to be generated.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    descriptions: tp.List[tp.Optional[str]] = [None] * num_samples
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback"><code class="name flex">
<span>def <span class="ident">set_custom_progress_callback</span></span>(<span>self, progress_callback:Â Optional[Callable[[int,Â int],Â None]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Override the default progress callback.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_progress_callback(self, progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None):
    &#34;&#34;&#34;Override the default progress callback.&#34;&#34;&#34;
    self._progress_callback = progress_callback</code></pre>
</details>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.set_generation_params"><code class="name flex">
<span>def <span class="ident">set_generation_params</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the generation parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def set_generation_params(self, *args, **kwargs):
    &#34;&#34;&#34;Set the generation parameters.&#34;&#34;&#34;
    raise NotImplementedError(&#34;No base implementation for setting generation params.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="audiocraft.models" href="index.html">audiocraft.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="audiocraft.models.genmodel.BaseGenModel" href="#audiocraft.models.genmodel.BaseGenModel">BaseGenModel</a></code></h4>
<ul class="">
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.audio_channels" href="#audiocraft.models.genmodel.BaseGenModel.audio_channels">audio_channels</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.frame_rate" href="#audiocraft.models.genmodel.BaseGenModel.frame_rate">frame_rate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate" href="#audiocraft.models.genmodel.BaseGenModel.generate">generate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_audio" href="#audiocraft.models.genmodel.BaseGenModel.generate_audio">generate_audio</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_continuation" href="#audiocraft.models.genmodel.BaseGenModel.generate_continuation">generate_continuation</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_unconditional" href="#audiocraft.models.genmodel.BaseGenModel.generate_unconditional">generate_unconditional</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.get_pretrained" href="#audiocraft.models.genmodel.BaseGenModel.get_pretrained">get_pretrained</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.sample_rate" href="#audiocraft.models.genmodel.BaseGenModel.sample_rate">sample_rate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback" href="#audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback">set_custom_progress_callback</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.set_generation_params" href="#audiocraft.models.genmodel.BaseGenModel.set_generation_params">set_generation_params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>