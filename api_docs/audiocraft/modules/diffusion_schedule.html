<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>audiocraft.modules.diffusion_schedule API documentation</title>
<meta name="description" content="Functions for Noise Schedule, defines diffusion process, reverse process and data processor." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>audiocraft.modules.diffusion_schedule</code></h1>
</header>
<section id="section-intro">
<p>Functions for Noise Schedule, defines diffusion process, reverse process and data processor.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

&#34;&#34;&#34;
Functions for Noise Schedule, defines diffusion process, reverse process and data processor.
&#34;&#34;&#34;

from collections import namedtuple
import random
import typing as tp
import julius
import torch

TrainingItem = namedtuple(&#34;TrainingItem&#34;, &#34;noisy noise step&#34;)


def betas_from_alpha_bar(alpha_bar):
    alphas = torch.cat([torch.Tensor([alpha_bar[0]]), alpha_bar[1:]/alpha_bar[:-1]])
    return 1 - alphas


class SampleProcessor(torch.nn.Module):
    def project_sample(self, x: torch.Tensor):
        &#34;&#34;&#34;Project the original sample to the &#39;space&#39; where the diffusion will happen.&#34;&#34;&#34;
        return x

    def return_sample(self, z: torch.Tensor):
        &#34;&#34;&#34;Project back from diffusion space to the actual sample space.&#34;&#34;&#34;
        return z


class MultiBandProcessor(SampleProcessor):
    &#34;&#34;&#34;
    MultiBand sample processor. The input audio is splitted across
    frequency bands evenly distributed in mel-scale.

    Each band will be rescaled to match the power distribution
    of Gaussian noise in that band, using online metrics
    computed on the first few samples.

    Args:
        n_bands (int): Number of mel-bands to split the signal over.
        sample_rate (int): Sample rate of the audio.
        num_samples (int): Number of samples to use to fit the rescaling
            for each band. The processor won&#39;t be stable
            until it has seen that many samples.
        power_std (float or list/tensor): The rescaling factor computed to match the
            power of Gaussian noise in each band is taken to
            that power, i.e. `1.` means full correction of the energy
            in each band, and values less than `1` means only partial
            correction. Can be used to balance the relative importance
            of low vs. high freq in typical audio signals.
    &#34;&#34;&#34;
    def __init__(self, n_bands: int = 8, sample_rate: float = 24_000,
                 num_samples: int = 10_000, power_std: tp.Union[float, tp.List[float], torch.Tensor] = 1.):
        super().__init__()
        self.n_bands = n_bands
        self.split_bands = julius.SplitBands(sample_rate, n_bands=n_bands)
        self.num_samples = num_samples
        self.power_std = power_std
        if isinstance(power_std, list):
            assert len(power_std) == n_bands
            power_std = torch.tensor(power_std)
        self.register_buffer(&#39;counts&#39;, torch.zeros(1))
        self.register_buffer(&#39;sum_x&#39;, torch.zeros(n_bands))
        self.register_buffer(&#39;sum_x2&#39;, torch.zeros(n_bands))
        self.register_buffer(&#39;sum_target_x2&#39;, torch.zeros(n_bands))
        self.counts: torch.Tensor
        self.sum_x: torch.Tensor
        self.sum_x2: torch.Tensor
        self.sum_target_x2: torch.Tensor

    @property
    def mean(self):
        mean = self.sum_x / self.counts
        return mean

    @property
    def std(self):
        std = (self.sum_x2 / self.counts - self.mean**2).clamp(min=0).sqrt()
        return std

    @property
    def target_std(self):
        target_std = self.sum_target_x2 / self.counts
        return target_std

    def project_sample(self, x: torch.Tensor):
        assert x.dim() == 3
        bands = self.split_bands(x)
        if self.counts.item() &lt; self.num_samples:
            ref_bands = self.split_bands(torch.randn_like(x))
            self.counts += len(x)
            self.sum_x += bands.mean(dim=(2, 3)).sum(dim=1)
            self.sum_x2 += bands.pow(2).mean(dim=(2, 3)).sum(dim=1)
            self.sum_target_x2 += ref_bands.pow(2).mean(dim=(2, 3)).sum(dim=1)
        rescale = (self.target_std / self.std.clamp(min=1e-12)) ** self.power_std  # same output size
        bands = (bands - self.mean.view(-1, 1, 1, 1)) * rescale.view(-1, 1, 1, 1)
        return bands.sum(dim=0)

    def return_sample(self, x: torch.Tensor):
        assert x.dim() == 3
        bands = self.split_bands(x)
        rescale = (self.std / self.target_std) ** self.power_std
        bands = bands * rescale.view(-1, 1, 1, 1) + self.mean.view(-1, 1, 1, 1)
        return bands.sum(dim=0)


class NoiseSchedule:
    &#34;&#34;&#34;Noise schedule for diffusion.

    Args:
        beta_t0 (float): Variance of the first diffusion step.
        beta_t1 (float): Variance of the last diffusion step.
        beta_exp (float): Power schedule exponent
        num_steps (int): Number of diffusion step.
        variance (str): choice of the sigma value for the denoising eq. Choices: &#34;beta&#34; or &#34;beta_tilde&#34;
        clip (float): clipping value for the denoising steps
        rescale (float): rescaling value to avoid vanishing signals unused by default (i.e 1)
        repartition (str): shape of the schedule only power schedule is supported
        sample_processor (SampleProcessor): Module that normalize data to match better the gaussian distribution
        noise_scale (float): Scaling factor for the noise
    &#34;&#34;&#34;
    def __init__(self, beta_t0: float = 1e-4, beta_t1: float = 0.02, num_steps: int = 1000, variance: str = &#39;beta&#39;,
                 clip: float = 5., rescale: float = 1., device=&#39;cuda&#39;, beta_exp: float = 1,
                 repartition: str = &#34;power&#34;, alpha_sigmoid: dict = {}, n_bands: tp.Optional[int] = None,
                 sample_processor: SampleProcessor = SampleProcessor(), noise_scale: float = 1.0, **kwargs):

        self.beta_t0 = beta_t0
        self.beta_t1 = beta_t1
        self.variance = variance
        self.num_steps = num_steps
        self.clip = clip
        self.sample_processor = sample_processor
        self.rescale = rescale
        self.n_bands = n_bands
        self.noise_scale = noise_scale
        assert n_bands is None
        if repartition == &#34;power&#34;:
            self.betas = torch.linspace(beta_t0 ** (1 / beta_exp), beta_t1 ** (1 / beta_exp), num_steps,
                                        device=device, dtype=torch.float) ** beta_exp
        else:
            raise RuntimeError(&#39;Not implemented&#39;)
        self.rng = random.Random(1234)

    def get_beta(self, step: tp.Union[int, torch.Tensor]):
        if self.n_bands is None:
            return self.betas[step]
        else:
            return self.betas[:, step]  # [n_bands, len(step)]

    def get_initial_noise(self, x: torch.Tensor):
        if self.n_bands is None:
            return torch.randn_like(x)
        return torch.randn((x.size(0), self.n_bands, x.size(2)))

    def get_alpha_bar(self, step: tp.Optional[tp.Union[int, torch.Tensor]] = None) -&gt; torch.Tensor:
        &#34;&#34;&#34;Return &#39;alpha_bar&#39;, either for a given step, or as a tensor with its value for each step.&#34;&#34;&#34;
        if step is None:
            return (1 - self.betas).cumprod(dim=-1)  # works for simgle and multi bands
        if type(step) is int:
            return (1 - self.betas[:step + 1]).prod()
        else:
            return (1 - self.betas).cumprod(dim=0)[step].view(-1, 1, 1)

    def get_training_item(self, x: torch.Tensor, tensor_step: bool = False) -&gt; TrainingItem:
        &#34;&#34;&#34;Create a noisy data item for diffusion model training:

        Args:
            x (torch.Tensor): clean audio data torch.tensor(bs, 1, T)
            tensor_step (bool): If tensor_step = false, only one step t is sample,
                the whole batch is diffused to the same step and t is int.
                If tensor_step = true, t is a tensor of size (x.size(0),)
                every element of the batch is diffused to a independently sampled.
        &#34;&#34;&#34;
        step: tp.Union[int, torch.Tensor]
        if tensor_step:
            bs = x.size(0)
            step = torch.randint(0, self.num_steps, size=(bs,), device=x.device)
        else:
            step = self.rng.randrange(self.num_steps)
        alpha_bar = self.get_alpha_bar(step)  # [batch_size, n_bands, 1]

        x = self.sample_processor.project_sample(x)
        noise = torch.randn_like(x)
        noisy = (alpha_bar.sqrt() / self.rescale) * x + (1 - alpha_bar).sqrt() * noise * self.noise_scale
        return TrainingItem(noisy, noise, step)

    def generate(self, model: torch.nn.Module, initial: tp.Optional[torch.Tensor] = None,
                 condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
        &#34;&#34;&#34;Full ddpm reverse process.

        Args:
            model (nn.Module): Diffusion model.
            initial (tensor): Initial Noise.
            condition (tensor): Input conditionning Tensor (e.g. encodec compressed representation).
            return_list (bool): Whether to return the whole process or only the sampled point.
        &#34;&#34;&#34;
        alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
        current = initial
        iterates = [initial]
        for step in range(self.num_steps)[::-1]:
            with torch.no_grad():
                estimate = model(current, step, condition=condition).sample
            alpha = 1 - self.betas[step]
            previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
            previous_alpha_bar = self.get_alpha_bar(step=step - 1)
            if step == 0:
                sigma2 = 0
            elif self.variance == &#39;beta&#39;:
                sigma2 = 1 - alpha
            elif self.variance == &#39;beta_tilde&#39;:
                sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
            elif self.variance == &#39;none&#39;:
                sigma2 = 0
            else:
                raise ValueError(f&#39;Invalid variance type {self.variance}&#39;)

            if sigma2 &gt; 0:
                previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
            if self.clip:
                previous = previous.clamp(-self.clip, self.clip)
            current = previous
            alpha_bar = previous_alpha_bar
            if step == 0:
                previous *= self.rescale
            if return_list:
                iterates.append(previous.cpu())

        if return_list:
            return iterates
        else:
            return self.sample_processor.return_sample(previous)

    def generate_subsampled(self, model: torch.nn.Module, initial: torch.Tensor, step_list: tp.Optional[list] = None,
                            condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
        &#34;&#34;&#34;Reverse process that only goes through Markov chain states in step_list.&#34;&#34;&#34;
        if step_list is None:
            step_list = list(range(1000))[::-50] + [0]
        alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
        alpha_bars_subsampled = (1 - self.betas).cumprod(dim=0)[list(reversed(step_list))].cpu()
        betas_subsampled = betas_from_alpha_bar(alpha_bars_subsampled)
        current = initial * self.noise_scale
        iterates = [current]
        for idx, step in enumerate(step_list[:-1]):
            with torch.no_grad():
                estimate = model(current, step, condition=condition).sample * self.noise_scale
            alpha = 1 - betas_subsampled[-1 - idx]
            previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
            previous_alpha_bar = self.get_alpha_bar(step_list[idx + 1])
            if step == step_list[-2]:
                sigma2 = 0
                previous_alpha_bar = torch.tensor(1.0)
            else:
                sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
            if sigma2 &gt; 0:
                previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
            if self.clip:
                previous = previous.clamp(-self.clip, self.clip)
            current = previous
            alpha_bar = previous_alpha_bar
            if step == 0:
                previous *= self.rescale
            if return_list:
                iterates.append(previous.cpu())
        if return_list:
            return iterates
        else:
            return self.sample_processor.return_sample(previous)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.betas_from_alpha_bar"><code class="name flex">
<span>def <span class="ident">betas_from_alpha_bar</span></span>(<span>alpha_bar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def betas_from_alpha_bar(alpha_bar):
    alphas = torch.cat([torch.Tensor([alpha_bar[0]]), alpha_bar[1:]/alpha_bar[:-1]])
    return 1 - alphas</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor"><code class="flex name class">
<span>class <span class="ident">MultiBandProcessor</span></span>
<span>(</span><span>n_bands: int = 8, sample_rate: float = 24000, num_samples: int = 10000, power_std: Union[float, List[float], torch.Tensor] = 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>MultiBand sample processor. The input audio is splitted across
frequency bands evenly distributed in mel-scale.</p>
<p>Each band will be rescaled to match the power distribution
of Gaussian noise in that band, using online metrics
computed on the first few samples.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_bands</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of mel-bands to split the signal over.</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Sample rate of the audio.</dd>
<dt><strong><code>num_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to use to fit the rescaling
for each band. The processor won't be stable
until it has seen that many samples.</dd>
</dl>
<p>power_std (float or list/tensor): The rescaling factor computed to match the
power of Gaussian noise in each band is taken to
that power, i.e. <code>1.</code> means full correction of the energy
in each band, and values less than <code>1</code> means only partial
correction. Can be used to balance the relative importance
of low vs. high freq in typical audio signals.
Initializes internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiBandProcessor(SampleProcessor):
    &#34;&#34;&#34;
    MultiBand sample processor. The input audio is splitted across
    frequency bands evenly distributed in mel-scale.

    Each band will be rescaled to match the power distribution
    of Gaussian noise in that band, using online metrics
    computed on the first few samples.

    Args:
        n_bands (int): Number of mel-bands to split the signal over.
        sample_rate (int): Sample rate of the audio.
        num_samples (int): Number of samples to use to fit the rescaling
            for each band. The processor won&#39;t be stable
            until it has seen that many samples.
        power_std (float or list/tensor): The rescaling factor computed to match the
            power of Gaussian noise in each band is taken to
            that power, i.e. `1.` means full correction of the energy
            in each band, and values less than `1` means only partial
            correction. Can be used to balance the relative importance
            of low vs. high freq in typical audio signals.
    &#34;&#34;&#34;
    def __init__(self, n_bands: int = 8, sample_rate: float = 24_000,
                 num_samples: int = 10_000, power_std: tp.Union[float, tp.List[float], torch.Tensor] = 1.):
        super().__init__()
        self.n_bands = n_bands
        self.split_bands = julius.SplitBands(sample_rate, n_bands=n_bands)
        self.num_samples = num_samples
        self.power_std = power_std
        if isinstance(power_std, list):
            assert len(power_std) == n_bands
            power_std = torch.tensor(power_std)
        self.register_buffer(&#39;counts&#39;, torch.zeros(1))
        self.register_buffer(&#39;sum_x&#39;, torch.zeros(n_bands))
        self.register_buffer(&#39;sum_x2&#39;, torch.zeros(n_bands))
        self.register_buffer(&#39;sum_target_x2&#39;, torch.zeros(n_bands))
        self.counts: torch.Tensor
        self.sum_x: torch.Tensor
        self.sum_x2: torch.Tensor
        self.sum_target_x2: torch.Tensor

    @property
    def mean(self):
        mean = self.sum_x / self.counts
        return mean

    @property
    def std(self):
        std = (self.sum_x2 / self.counts - self.mean**2).clamp(min=0).sqrt()
        return std

    @property
    def target_std(self):
        target_std = self.sum_target_x2 / self.counts
        return target_std

    def project_sample(self, x: torch.Tensor):
        assert x.dim() == 3
        bands = self.split_bands(x)
        if self.counts.item() &lt; self.num_samples:
            ref_bands = self.split_bands(torch.randn_like(x))
            self.counts += len(x)
            self.sum_x += bands.mean(dim=(2, 3)).sum(dim=1)
            self.sum_x2 += bands.pow(2).mean(dim=(2, 3)).sum(dim=1)
            self.sum_target_x2 += ref_bands.pow(2).mean(dim=(2, 3)).sum(dim=1)
        rescale = (self.target_std / self.std.clamp(min=1e-12)) ** self.power_std  # same output size
        bands = (bands - self.mean.view(-1, 1, 1, 1)) * rescale.view(-1, 1, 1, 1)
        return bands.sum(dim=0)

    def return_sample(self, x: torch.Tensor):
        assert x.dim() == 3
        bands = self.split_bands(x)
        rescale = (self.std / self.target_std) ** self.power_std
        bands = bands * rescale.view(-1, 1, 1, 1) + self.mean.view(-1, 1, 1, 1)
        return bands.sum(dim=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiocraft.modules.diffusion_schedule.SampleProcessor" href="#audiocraft.modules.diffusion_schedule.SampleProcessor">SampleProcessor</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.call_super_init"><code class="name">var <span class="ident">call_super_init</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.mean"><code class="name">var <span class="ident">mean</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean(self):
    mean = self.sum_x / self.counts
    return mean</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.std"><code class="name">var <span class="ident">std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self):
    std = (self.sum_x2 / self.counts - self.mean**2).clamp(min=0).sqrt()
    return std</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.MultiBandProcessor.target_std"><code class="name">var <span class="ident">target_std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def target_std(self):
    target_std = self.sum_target_x2 / self.counts
    return target_std</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiocraft.modules.diffusion_schedule.SampleProcessor" href="#audiocraft.modules.diffusion_schedule.SampleProcessor">SampleProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.forward" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.forward">forward</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.project_sample" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.project_sample">project_sample</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.return_sample" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.return_sample">return_sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule"><code class="flex name class">
<span>class <span class="ident">NoiseSchedule</span></span>
<span>(</span><span>beta_t0: float = 0.0001, beta_t1: float = 0.02, num_steps: int = 1000, variance: str = 'beta', clip: float = 5.0, rescale: float = 1.0, device='cuda', beta_exp: float = 1, repartition: str = 'power', alpha_sigmoid: dict = {}, n_bands: Optional[int] = None, sample_processor: <a title="audiocraft.modules.diffusion_schedule.SampleProcessor" href="#audiocraft.modules.diffusion_schedule.SampleProcessor">SampleProcessor</a> = SampleProcessor(), noise_scale: float = 1.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Noise schedule for diffusion.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>beta_t0</code></strong> :&ensp;<code>float</code></dt>
<dd>Variance of the first diffusion step.</dd>
<dt><strong><code>beta_t1</code></strong> :&ensp;<code>float</code></dt>
<dd>Variance of the last diffusion step.</dd>
<dt><strong><code>beta_exp</code></strong> :&ensp;<code>float</code></dt>
<dd>Power schedule exponent</dd>
<dt><strong><code>num_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of diffusion step.</dd>
<dt><strong><code>variance</code></strong> :&ensp;<code>str</code></dt>
<dd>choice of the sigma value for the denoising eq. Choices: "beta" or "beta_tilde"</dd>
<dt><strong><code>clip</code></strong> :&ensp;<code>float</code></dt>
<dd>clipping value for the denoising steps</dd>
<dt><strong><code>rescale</code></strong> :&ensp;<code>float</code></dt>
<dd>rescaling value to avoid vanishing signals unused by default (i.e 1)</dd>
<dt><strong><code>repartition</code></strong> :&ensp;<code>str</code></dt>
<dd>shape of the schedule only power schedule is supported</dd>
<dt><strong><code>sample_processor</code></strong> :&ensp;<code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor" href="#audiocraft.modules.diffusion_schedule.SampleProcessor">SampleProcessor</a></code></dt>
<dd>Module that normalize data to match better the gaussian distribution</dd>
<dt><strong><code>noise_scale</code></strong> :&ensp;<code>float</code></dt>
<dd>Scaling factor for the noise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoiseSchedule:
    &#34;&#34;&#34;Noise schedule for diffusion.

    Args:
        beta_t0 (float): Variance of the first diffusion step.
        beta_t1 (float): Variance of the last diffusion step.
        beta_exp (float): Power schedule exponent
        num_steps (int): Number of diffusion step.
        variance (str): choice of the sigma value for the denoising eq. Choices: &#34;beta&#34; or &#34;beta_tilde&#34;
        clip (float): clipping value for the denoising steps
        rescale (float): rescaling value to avoid vanishing signals unused by default (i.e 1)
        repartition (str): shape of the schedule only power schedule is supported
        sample_processor (SampleProcessor): Module that normalize data to match better the gaussian distribution
        noise_scale (float): Scaling factor for the noise
    &#34;&#34;&#34;
    def __init__(self, beta_t0: float = 1e-4, beta_t1: float = 0.02, num_steps: int = 1000, variance: str = &#39;beta&#39;,
                 clip: float = 5., rescale: float = 1., device=&#39;cuda&#39;, beta_exp: float = 1,
                 repartition: str = &#34;power&#34;, alpha_sigmoid: dict = {}, n_bands: tp.Optional[int] = None,
                 sample_processor: SampleProcessor = SampleProcessor(), noise_scale: float = 1.0, **kwargs):

        self.beta_t0 = beta_t0
        self.beta_t1 = beta_t1
        self.variance = variance
        self.num_steps = num_steps
        self.clip = clip
        self.sample_processor = sample_processor
        self.rescale = rescale
        self.n_bands = n_bands
        self.noise_scale = noise_scale
        assert n_bands is None
        if repartition == &#34;power&#34;:
            self.betas = torch.linspace(beta_t0 ** (1 / beta_exp), beta_t1 ** (1 / beta_exp), num_steps,
                                        device=device, dtype=torch.float) ** beta_exp
        else:
            raise RuntimeError(&#39;Not implemented&#39;)
        self.rng = random.Random(1234)

    def get_beta(self, step: tp.Union[int, torch.Tensor]):
        if self.n_bands is None:
            return self.betas[step]
        else:
            return self.betas[:, step]  # [n_bands, len(step)]

    def get_initial_noise(self, x: torch.Tensor):
        if self.n_bands is None:
            return torch.randn_like(x)
        return torch.randn((x.size(0), self.n_bands, x.size(2)))

    def get_alpha_bar(self, step: tp.Optional[tp.Union[int, torch.Tensor]] = None) -&gt; torch.Tensor:
        &#34;&#34;&#34;Return &#39;alpha_bar&#39;, either for a given step, or as a tensor with its value for each step.&#34;&#34;&#34;
        if step is None:
            return (1 - self.betas).cumprod(dim=-1)  # works for simgle and multi bands
        if type(step) is int:
            return (1 - self.betas[:step + 1]).prod()
        else:
            return (1 - self.betas).cumprod(dim=0)[step].view(-1, 1, 1)

    def get_training_item(self, x: torch.Tensor, tensor_step: bool = False) -&gt; TrainingItem:
        &#34;&#34;&#34;Create a noisy data item for diffusion model training:

        Args:
            x (torch.Tensor): clean audio data torch.tensor(bs, 1, T)
            tensor_step (bool): If tensor_step = false, only one step t is sample,
                the whole batch is diffused to the same step and t is int.
                If tensor_step = true, t is a tensor of size (x.size(0),)
                every element of the batch is diffused to a independently sampled.
        &#34;&#34;&#34;
        step: tp.Union[int, torch.Tensor]
        if tensor_step:
            bs = x.size(0)
            step = torch.randint(0, self.num_steps, size=(bs,), device=x.device)
        else:
            step = self.rng.randrange(self.num_steps)
        alpha_bar = self.get_alpha_bar(step)  # [batch_size, n_bands, 1]

        x = self.sample_processor.project_sample(x)
        noise = torch.randn_like(x)
        noisy = (alpha_bar.sqrt() / self.rescale) * x + (1 - alpha_bar).sqrt() * noise * self.noise_scale
        return TrainingItem(noisy, noise, step)

    def generate(self, model: torch.nn.Module, initial: tp.Optional[torch.Tensor] = None,
                 condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
        &#34;&#34;&#34;Full ddpm reverse process.

        Args:
            model (nn.Module): Diffusion model.
            initial (tensor): Initial Noise.
            condition (tensor): Input conditionning Tensor (e.g. encodec compressed representation).
            return_list (bool): Whether to return the whole process or only the sampled point.
        &#34;&#34;&#34;
        alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
        current = initial
        iterates = [initial]
        for step in range(self.num_steps)[::-1]:
            with torch.no_grad():
                estimate = model(current, step, condition=condition).sample
            alpha = 1 - self.betas[step]
            previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
            previous_alpha_bar = self.get_alpha_bar(step=step - 1)
            if step == 0:
                sigma2 = 0
            elif self.variance == &#39;beta&#39;:
                sigma2 = 1 - alpha
            elif self.variance == &#39;beta_tilde&#39;:
                sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
            elif self.variance == &#39;none&#39;:
                sigma2 = 0
            else:
                raise ValueError(f&#39;Invalid variance type {self.variance}&#39;)

            if sigma2 &gt; 0:
                previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
            if self.clip:
                previous = previous.clamp(-self.clip, self.clip)
            current = previous
            alpha_bar = previous_alpha_bar
            if step == 0:
                previous *= self.rescale
            if return_list:
                iterates.append(previous.cpu())

        if return_list:
            return iterates
        else:
            return self.sample_processor.return_sample(previous)

    def generate_subsampled(self, model: torch.nn.Module, initial: torch.Tensor, step_list: tp.Optional[list] = None,
                            condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
        &#34;&#34;&#34;Reverse process that only goes through Markov chain states in step_list.&#34;&#34;&#34;
        if step_list is None:
            step_list = list(range(1000))[::-50] + [0]
        alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
        alpha_bars_subsampled = (1 - self.betas).cumprod(dim=0)[list(reversed(step_list))].cpu()
        betas_subsampled = betas_from_alpha_bar(alpha_bars_subsampled)
        current = initial * self.noise_scale
        iterates = [current]
        for idx, step in enumerate(step_list[:-1]):
            with torch.no_grad():
                estimate = model(current, step, condition=condition).sample * self.noise_scale
            alpha = 1 - betas_subsampled[-1 - idx]
            previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
            previous_alpha_bar = self.get_alpha_bar(step_list[idx + 1])
            if step == step_list[-2]:
                sigma2 = 0
                previous_alpha_bar = torch.tensor(1.0)
            else:
                sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
            if sigma2 &gt; 0:
                previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
            if self.clip:
                previous = previous.clamp(-self.clip, self.clip)
            current = previous
            alpha_bar = previous_alpha_bar
            if step == 0:
                previous *= self.rescale
            if return_list:
                iterates.append(previous.cpu())
        if return_list:
            return iterates
        else:
            return self.sample_processor.return_sample(previous)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, model: torch.nn.modules.module.Module, initial: Optional[torch.Tensor] = None, condition: Optional[torch.Tensor] = None, return_list: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Full ddpm reverse process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>nn.Module</code></dt>
<dd>Diffusion model.</dd>
<dt><strong><code>initial</code></strong> :&ensp;<code>tensor</code></dt>
<dd>Initial Noise.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>tensor</code></dt>
<dd>Input conditionning Tensor (e.g. encodec compressed representation).</dd>
<dt><strong><code>return_list</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the whole process or only the sampled point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, model: torch.nn.Module, initial: tp.Optional[torch.Tensor] = None,
             condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
    &#34;&#34;&#34;Full ddpm reverse process.

    Args:
        model (nn.Module): Diffusion model.
        initial (tensor): Initial Noise.
        condition (tensor): Input conditionning Tensor (e.g. encodec compressed representation).
        return_list (bool): Whether to return the whole process or only the sampled point.
    &#34;&#34;&#34;
    alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
    current = initial
    iterates = [initial]
    for step in range(self.num_steps)[::-1]:
        with torch.no_grad():
            estimate = model(current, step, condition=condition).sample
        alpha = 1 - self.betas[step]
        previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
        previous_alpha_bar = self.get_alpha_bar(step=step - 1)
        if step == 0:
            sigma2 = 0
        elif self.variance == &#39;beta&#39;:
            sigma2 = 1 - alpha
        elif self.variance == &#39;beta_tilde&#39;:
            sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
        elif self.variance == &#39;none&#39;:
            sigma2 = 0
        else:
            raise ValueError(f&#39;Invalid variance type {self.variance}&#39;)

        if sigma2 &gt; 0:
            previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
        if self.clip:
            previous = previous.clamp(-self.clip, self.clip)
        current = previous
        alpha_bar = previous_alpha_bar
        if step == 0:
            previous *= self.rescale
        if return_list:
            iterates.append(previous.cpu())

    if return_list:
        return iterates
    else:
        return self.sample_processor.return_sample(previous)</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.generate_subsampled"><code class="name flex">
<span>def <span class="ident">generate_subsampled</span></span>(<span>self, model: torch.nn.modules.module.Module, initial: torch.Tensor, step_list: Optional[list] = None, condition: Optional[torch.Tensor] = None, return_list: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverse process that only goes through Markov chain states in step_list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_subsampled(self, model: torch.nn.Module, initial: torch.Tensor, step_list: tp.Optional[list] = None,
                        condition: tp.Optional[torch.Tensor] = None, return_list: bool = False):
    &#34;&#34;&#34;Reverse process that only goes through Markov chain states in step_list.&#34;&#34;&#34;
    if step_list is None:
        step_list = list(range(1000))[::-50] + [0]
    alpha_bar = self.get_alpha_bar(step=self.num_steps - 1)
    alpha_bars_subsampled = (1 - self.betas).cumprod(dim=0)[list(reversed(step_list))].cpu()
    betas_subsampled = betas_from_alpha_bar(alpha_bars_subsampled)
    current = initial * self.noise_scale
    iterates = [current]
    for idx, step in enumerate(step_list[:-1]):
        with torch.no_grad():
            estimate = model(current, step, condition=condition).sample * self.noise_scale
        alpha = 1 - betas_subsampled[-1 - idx]
        previous = (current - (1 - alpha) / (1 - alpha_bar).sqrt() * estimate) / alpha.sqrt()
        previous_alpha_bar = self.get_alpha_bar(step_list[idx + 1])
        if step == step_list[-2]:
            sigma2 = 0
            previous_alpha_bar = torch.tensor(1.0)
        else:
            sigma2 = (1 - previous_alpha_bar) / (1 - alpha_bar) * (1 - alpha)
        if sigma2 &gt; 0:
            previous += sigma2**0.5 * torch.randn_like(previous) * self.noise_scale
        if self.clip:
            previous = previous.clamp(-self.clip, self.clip)
        current = previous
        alpha_bar = previous_alpha_bar
        if step == 0:
            previous *= self.rescale
        if return_list:
            iterates.append(previous.cpu())
    if return_list:
        return iterates
    else:
        return self.sample_processor.return_sample(previous)</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_alpha_bar"><code class="name flex">
<span>def <span class="ident">get_alpha_bar</span></span>(<span>self, step: Union[int, torch.Tensor, None] = None) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Return 'alpha_bar', either for a given step, or as a tensor with its value for each step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alpha_bar(self, step: tp.Optional[tp.Union[int, torch.Tensor]] = None) -&gt; torch.Tensor:
    &#34;&#34;&#34;Return &#39;alpha_bar&#39;, either for a given step, or as a tensor with its value for each step.&#34;&#34;&#34;
    if step is None:
        return (1 - self.betas).cumprod(dim=-1)  # works for simgle and multi bands
    if type(step) is int:
        return (1 - self.betas[:step + 1]).prod()
    else:
        return (1 - self.betas).cumprod(dim=0)[step].view(-1, 1, 1)</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_beta"><code class="name flex">
<span>def <span class="ident">get_beta</span></span>(<span>self, step: Union[int, torch.Tensor])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_beta(self, step: tp.Union[int, torch.Tensor]):
    if self.n_bands is None:
        return self.betas[step]
    else:
        return self.betas[:, step]  # [n_bands, len(step)]</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_initial_noise"><code class="name flex">
<span>def <span class="ident">get_initial_noise</span></span>(<span>self, x: torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_initial_noise(self, x: torch.Tensor):
    if self.n_bands is None:
        return torch.randn_like(x)
    return torch.randn((x.size(0), self.n_bands, x.size(2)))</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_training_item"><code class="name flex">
<span>def <span class="ident">get_training_item</span></span>(<span>self, x: torch.Tensor, tensor_step: bool = False) ‑> <a title="audiocraft.modules.diffusion_schedule.TrainingItem" href="#audiocraft.modules.diffusion_schedule.TrainingItem">TrainingItem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a noisy data item for diffusion model training:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>clean audio data torch.tensor(bs, 1, T)</dd>
<dt><strong><code>tensor_step</code></strong> :&ensp;<code>bool</code></dt>
<dd>If tensor_step = false, only one step t is sample,
the whole batch is diffused to the same step and t is int.
If tensor_step = true, t is a tensor of size (x.size(0),)
every element of the batch is diffused to a independently sampled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_training_item(self, x: torch.Tensor, tensor_step: bool = False) -&gt; TrainingItem:
    &#34;&#34;&#34;Create a noisy data item for diffusion model training:

    Args:
        x (torch.Tensor): clean audio data torch.tensor(bs, 1, T)
        tensor_step (bool): If tensor_step = false, only one step t is sample,
            the whole batch is diffused to the same step and t is int.
            If tensor_step = true, t is a tensor of size (x.size(0),)
            every element of the batch is diffused to a independently sampled.
    &#34;&#34;&#34;
    step: tp.Union[int, torch.Tensor]
    if tensor_step:
        bs = x.size(0)
        step = torch.randint(0, self.num_steps, size=(bs,), device=x.device)
    else:
        step = self.rng.randrange(self.num_steps)
    alpha_bar = self.get_alpha_bar(step)  # [batch_size, n_bands, 1]

    x = self.sample_processor.project_sample(x)
    noise = torch.randn_like(x)
    noisy = (alpha_bar.sqrt() / self.rescale) * x + (1 - alpha_bar).sqrt() * noise * self.noise_scale
    return TrainingItem(noisy, noise, step)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor"><code class="flex name class">
<span>class <span class="ident">SampleProcessor</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>
<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As per the example above, an <code>__init__()</code> call to the parent class
must be made before assignment on the child.</p>
</div>
<p>:ivar training: Boolean represents whether this module is in training or
evaluation mode.
:vartype training: bool</p>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SampleProcessor(torch.nn.Module):
    def project_sample(self, x: torch.Tensor):
        &#34;&#34;&#34;Project the original sample to the &#39;space&#39; where the diffusion will happen.&#34;&#34;&#34;
        return x

    def return_sample(self, z: torch.Tensor):
        &#34;&#34;&#34;Project back from diffusion space to the actual sample space.&#34;&#34;&#34;
        return z</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor">MultiBandProcessor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.call_super_init"><code class="name">var <span class="ident">call_super_init</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, *input: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _forward_unimplemented(self, *input: Any) -&gt; None:
    r&#34;&#34;&#34;Defines the computation performed at every call.

    Should be overridden by all subclasses.

    .. note::
        Although the recipe for forward pass needs to be defined within
        this function, one should call the :class:`Module` instance afterwards
        instead of this since the former takes care of running the
        registered hooks while the latter silently ignores them.
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Module [{type(self).__name__}] is missing the required \&#34;forward\&#34; function&#34;)</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.project_sample"><code class="name flex">
<span>def <span class="ident">project_sample</span></span>(<span>self, x: torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Project the original sample to the 'space' where the diffusion will happen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project_sample(self, x: torch.Tensor):
    &#34;&#34;&#34;Project the original sample to the &#39;space&#39; where the diffusion will happen.&#34;&#34;&#34;
    return x</code></pre>
</details>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.SampleProcessor.return_sample"><code class="name flex">
<span>def <span class="ident">return_sample</span></span>(<span>self, z: torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Project back from diffusion space to the actual sample space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_sample(self, z: torch.Tensor):
    &#34;&#34;&#34;Project back from diffusion space to the actual sample space.&#34;&#34;&#34;
    return z</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.TrainingItem"><code class="flex name class">
<span>class <span class="ident">TrainingItem</span></span>
<span>(</span><span>noisy, noise, step)</span>
</code></dt>
<dd>
<div class="desc"><p>TrainingItem(noisy, noise, step)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.modules.diffusion_schedule.TrainingItem.noise"><code class="name">var <span class="ident">noise</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.TrainingItem.noisy"><code class="name">var <span class="ident">noisy</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="audiocraft.modules.diffusion_schedule.TrainingItem.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="audiocraft.modules" href="index.html">audiocraft.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="audiocraft.modules.diffusion_schedule.betas_from_alpha_bar" href="#audiocraft.modules.diffusion_schedule.betas_from_alpha_bar">betas_from_alpha_bar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor">MultiBandProcessor</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.call_super_init" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.call_super_init">call_super_init</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.dump_patches" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.dump_patches">dump_patches</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.mean" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.mean">mean</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.std" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.std">std</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.target_std" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.target_std">target_std</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.MultiBandProcessor.training" href="#audiocraft.modules.diffusion_schedule.MultiBandProcessor.training">training</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule">NoiseSchedule</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.generate" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.generate">generate</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.generate_subsampled" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.generate_subsampled">generate_subsampled</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_alpha_bar" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.get_alpha_bar">get_alpha_bar</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_beta" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.get_beta">get_beta</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_initial_noise" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.get_initial_noise">get_initial_noise</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.NoiseSchedule.get_training_item" href="#audiocraft.modules.diffusion_schedule.NoiseSchedule.get_training_item">get_training_item</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor" href="#audiocraft.modules.diffusion_schedule.SampleProcessor">SampleProcessor</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.call_super_init" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.call_super_init">call_super_init</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.dump_patches" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.dump_patches">dump_patches</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.forward" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.forward">forward</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.project_sample" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.project_sample">project_sample</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.return_sample" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.return_sample">return_sample</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.SampleProcessor.training" href="#audiocraft.modules.diffusion_schedule.SampleProcessor.training">training</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiocraft.modules.diffusion_schedule.TrainingItem" href="#audiocraft.modules.diffusion_schedule.TrainingItem">TrainingItem</a></code></h4>
<ul class="">
<li><code><a title="audiocraft.modules.diffusion_schedule.TrainingItem.noise" href="#audiocraft.modules.diffusion_schedule.TrainingItem.noise">noise</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.TrainingItem.noisy" href="#audiocraft.modules.diffusion_schedule.TrainingItem.noisy">noisy</a></code></li>
<li><code><a title="audiocraft.modules.diffusion_schedule.TrainingItem.step" href="#audiocraft.modules.diffusion_schedule.TrainingItem.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>